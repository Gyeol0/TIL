# 탐욕(그리디)

## 탐욕 알고리즘(Greedy)

* 최적해를 구하는 데 사용되는 근시안적인 방법
* 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택
* 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 전체의 최적이라는 보장은 없다.
* 일반적으로, 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근

1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해집합에 추가
2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지를 확인, 문제를 위반하지 않는지
3. 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지 확인, 아니라면 1부터 다시

### 거스름돈 줄이기

1. 해 선택 : 단위가 큰 동전으로 만들면 개수가 줄어들므로, 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가
2. 실행 가능성 검사 : 거스름돈이 액수를 초과하는지 확인, 초과하면 마지막 동전을 빼고 1로 돌아감
3. 해 검사 : 거스름돈이 액수와 일치해야 하므로 부족하면 1로 돌아감

* 그러나 400원 짜리 동전이 있다면 배수 관계가 아니기 때문에 불가능

### Baby_gin

```python
def Baby_gin2(number):
    count = [0] * 10
    run = 0
    triplet = 0
    # 자리수의 count 리스트를 만들어서 3 이상이면 triplet, 연속해서 1 이상이면 run
    for i in range(6):
        count[number % 10] += 1
        number = number // 10

    for i in range(8):
        # run 탐색
        if count[i] > 0 and count[i+1] >0 and count[i+2] >0:
            run += 1
            count[i] -= 1
            count[i + 1] -= 1
            count[i + 2] -= 1
            
        # triplet 탐색
        if count[i] >= 3:
            count[i] -= 3
            triplet += 1
    if run + triplet == 2:
        return True
    return False
num = int(input())
print(Baby_gin2(num))
```



### 탐욕 기법과 DP 비교

* 탐욕 : 매 단계에서, 가장 좋게 보이는 것을 빠르게 선택한다, 지역 최적 선택(local optimal choice)
* DP :  매 단계의 선택은 해결한 하위문제의 해를 기반으로 한다.
* 탐욕 : 하위 문제를 풀기 전에 (탐욕적)선택이 먼저 이루어진다.
* DP : 하위 문제가 우선 해결된다
* 탐욕 : Top -down 방식
* DP : Bottom -up 방식, Top-down할 때도 있음
* 탐욕 : 일반적으로 빠르고 간결하다
* DP : 좀 더 느리고, 복잡하다



## 대표 알고리즘

### Prim

* N 개의 노드에 대한 최소 신장 트리(MST)를 찾는다
* 서브트리를 확장하면서 MST를 찾는다

### Kruskal(크루스칼)

* N개의 노드에 대한 최소 신장 트리(MST)를 찾는다.
* 싸이클이 없는 서브 그래프를 확장하면서 MST를 찾는다.

### Dijkstra(다익스트라)

* 주어진 정점에서 다른 정점들에 대한 최단 경로를 찾는다.
* 주어진 정점에서 가장 가까운 정점을 찾고, 그 다음을 정점을 반복해서 찾는다.

### Huffman tree & code

* 문서의 압축을 위해 문자들의 빈도수에 따라 코드 값을 부여한다.
* 출현 빈도가 낮은 문자부터 선택해서 이진트리를 완성하고 코드값을 부여한다.