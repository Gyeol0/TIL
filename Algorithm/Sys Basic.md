# System Basic

## 표준 입출력

```python
import sys
sys.stdin = open("input.txt", "r")
sys.stdout = open("output.txt", "w")

text = input()
print(text)
```

* 실행 콘솔(입출력 창)과 프로그램 간의 연결을 std, 스탠다드 스트림
* `sys.stdin`으로 콘솔과 연결하는 것이 아니라 input.txt와 프로그램 간 연결
  * 파이참 입력 버퍼 약 1MB
  * 큰 파일을 처리할 때, 1MB가 넘어가는 입력 값을 처리할 때 사용
* `sys.stdout` 으로 콘솔과 연결하는 것이 아니라 output.txt와 프로그램 간 연결



## 비트 연산

* & : 비트 단위로 AND 연산
* | : 비트 단위로 OR 연산
* ^ : 비트 단위로 XOR연산(같으면 0, 다르면 1)
* ~ : 단항 연산자로서 피연산자의 모든 비트를 반전
* << : 피연산자의 비트 열을 왼쪽으로 이동
  * `1<<n`
  * 2^n의 값을 가진다
  * 원소가 n개 일 때의 모든 부분집합의 수
  * Power set(모든 부분 집합)
  * 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 됨
* `i & (1<<j)`
  * 계산 결과는 i의 j번째 비트가 1인지 아닌지를 의미

```python
def bitPirnt(i):
    output = ''
    for j in range(7, -1, -1):
        if i & (1<<j):
            output += '1'
        else:
            output += '0'
print(bitPirnt(-4))
print(bitPirnt(-3))
print(bitPirnt(1))
print(bitPirnt(2))
print(bitPirnt(3))
print(bitPirnt(4))

"""
1 : 0000001
~(1) : 1111110
~(1) + 1 = -1 = 2의 보수 : 1111111
2의 보수 = 현재 비트보다 한 자리 더 많은 2의 제곱수와의 차이
""" 
```

### 엔디안(Endianness)

* 컴퓨터의 메모리와 같은 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법
* HW 아키텍처마다 다름
* 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산 할 때, 제대로 이해하지 않으면 오류 발생 가능
* 빅 엔디안(Big-endian)
  * 보통 큰 단위가 앞에
* 리틀 엔디안(Little-endian)
  * 작은 단위가 앞에. 대다수 데스크탑



## 진수

* 10진수를 타 진수로 변환
  * 원하는 타진법의 수로 나눈 뒤 나머지를 거꾸로
* 타 진수를 10진수로
  * `(135)8 = 1*8^2 + 3*8^1 + 5*8^0 = 93`
  * `(135.12)8 = 1*8^2 + 3*8^1 + 5*8^0 + 18*^(-1) + 2*8^(-2) = 93.15625`

### 보수

* 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 반대로
  * -6이면 6의 비트 표현하고 반대로 뒤집기
* 2의 보수 : 1의 보수 + 1



## 실수

* 컴퓨터는 부동 소수점(floating-point) 표기법 사용
* 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현
  * 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수 승으로 표현
* 가수부(mantissa) : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
* 지수부(expoenet) ; 실제 소수점의 위치를 지수 승으로 표현한 것
* 단정도 실수(32비트), 배정도 실수(64비트)
  * 단정도는 부호 1비트, 지수 8비트, 가수 23비트
  * 배정도는 부호 1비트, 지수 11비트, 가수 52비트
  * 단정도 실수의 지수 부분을 만들 때, 익세스(excess) 표현법 사용
  * 익세스 표현법 : 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수표현하는 방법
* 컴퓨터는 실수를 근사적으로 표현
  * 이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사 값으로 젖아
  * 이때의 작은 오차가 다른 결과 -> 실수 계산 조심
* 32 비트 실수형 유효자릿수 = 6
* 32비트는 15