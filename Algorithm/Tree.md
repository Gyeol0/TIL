# Tree

## 개념

* 싸이클이 없는 무향 연결 그래프
* 비선형 구조
* 1:n 자료구조
* 계층형 자료구조
* 최상위 노드 : 루트
* n(>=0)개의 분리 집합으로 분리, 이들은 하나틔 트리가 되며, 루트의 부트리(subtree)
* 두 노드, 정점 간 유일한 간선(경로)이 존재
* 각 노드는 최대 하나의 부모노드, 자식노드가 없거나 하나 이상 존재 가능

### 용어

* 노드(node) : 트리의 원소
* 간선(edge) : 노드를 연결하는 선
* 루트 노드(root node) : 트리의 시작 노드
* 형제 노드(sibiling node) : 같은 부모 노드를 가지는 자식 노드들
* 조상 노드 : 루트노드까지 이르는 경로에 있는 모든 노드들
* 서브 트리(subtree) : 부모 노드와 간선을 끊었을 때 생성되는 트리
* 자손 노드 : 서브 트이에 있는 하위 레벨 노드들
* 차수(degree)
  * 노드의 차수 : 노드에 연결된 자식 노드 수
  * 트리의 차수 : 트리 노드의 차수의 최댓값
  * 단말 노드(리프 노드) : 차수 0인 노드, 자식 노드x
* 높이
  * 노드의 높이 : 루트에서 노드까지의 간선 수, 노드 레벨
  * 트리의 높이 : 트리에 있는 높이의 최댓값



## 이진트리

* 모든 노드들이 2개의 서브 트리를 갖는 형태
* 각 노드가 자식 노드를 최대 2개 까지만 가질 수 있음
* 레벨이 i인 노드의 최대 개수는 2^i 개
* 높이가 h인 이진 트리의 노드 최소 개수는 (h+1)개, 최대는 (2^(h+1) + 1)개

### 포화 이진트리(Full Binary Tree)

* 모든 레벨이 포화상태로 차 있는 이진 트리
* 노드 2의(h+1)승 + 1 개
* 노드 번호가 정해져 있음, 위부터 왼쪽부터 1,2,3...

### 완전 이진트리(Complete Binary Tree)

* 포화일 수도 아닐 수도
* 포화 이진트리와 같이 자리마다 번호가 정해져 있음
* 개수가 n이라고 했을 때, 1부터 n번까지 비어있는 번호가 없어야 함

### 편향 이진트리(Skewd Binary Tree)

* 높이 h에 대한 최소 개수의 노드를 가짐
* 한 쪽 방향의 자식 노드만을 가짐
  * 왼쪽 편향 이진트리
  * 오른쪽 편향 이진트리

### 순회(traversal)

* 트리의 각 노드를 중복되지 않게 전부 방문(visit)
* 트리는 비선형 구조 -> 선후 연결관계를 알 수 없다.

1. 전위순회(preorder traversal) : VLR
   * 부모노드 방문 후, 자식노드를 좌, 우 순서로 방문
2. 중위순회(inorder traversal) : LVR
   * 왼쪽 자식, 부모, 오른쪽 자식 순으로 방문
3. 후위순회(postorder traversal) : LRV
   * 왼쪽 자식, 오른쪽 자식, 부모 순으로 방문

트리, 왼쪽 서브트리를 T1, 오른쪽을 T2라고 함

​		    	   A(T0)

   B                             C

D         E                 F     G

​          H    I 

### 전위순회(preorder traversal)

1. 현재 노드 방문 처리 - V
2. 현재 노드 왼쪽 서브트리로 이동 - L
3. 현재 노드 오른쪽 서브트리로 이동 - R

```python
def preorder_traversal(T):
    if T:
        visit(T)
        preorder_traversal(T.left)
        preorder_traversal(T.right)
```

* 뭔가 dfs랑 비슷?
* 왼쪽부터 보겠다
* T0 -> T1 -> T2
* A - B - D - E - H - I - C - F - G

### 중위순회(inorder traversal)

1. 현재 노드 왼쪽 서브트리로 이동 - L
2. 현재 노드 방문 처리 - V
3. 현재 노드 오른쪽 서브트리로 이동 - R

```python
def inorder_traversal(T):
    if T:
        inorder_traversal(T.left)
        visit(T)
        inorder_traversal(T.right)
```

* T1 -> T0 -> T2
* D - B - H - E - I - A - F - C - G

### 후위순회(postorder traversal)

1. 현재 노드 왼쪽 서브트리로 이동 - L
2. 현재 노드 오른쪽 서브트리로 이동 - R
3. 현재 노드 방문 처리 - V

```python
def inorder_traversal(T):
    if T:
        inorder_traversal(T.left)
        inorder_traversal(T.right)
        visit(T)
```

* T1 -> T2 -> T0
* D - H - I - E - B - F - G - C - A
* 자식 노드들이 갖고 있는 정보를 모아서 위로 올려야겠어, 이럴 때 사용

### 배열

* 배열일 이용해 이진트리 표현
* 왼쪽, 위부터 번호를 차례서 부여
* 완전, 포화 이진트리에 사용
* 노드 번호가 i인 노드의 부모 노드 번호 [i  / 2]보다 작거나 같은 최대 정수 i / / 2
* 노드 번호가 i 인 노드의 왼쪽 자식 노드 번호 : 2 * i
* 노드 번호가 i 인 노드의 왼쪽 자식 노드 번호 : 2 * i  + 1
* 레벨 n의 노드 시작 번호 2의 n 승
* 자신의 부모 노드를 담는 배열을 만들어, 부모 노드가 없는 인덱스가 루트 노드이다~
* 단점
  * 편향 이진 트리의 경우 사용하지 않는 메모리 낭비가 심함
  * 트리 중간에 새로운 노드를 삽입하거나 삭제할 경우, 배열의 크기 변경이 어려워 비효율적

```python
if ch1[p] == 0:
    ch1[p] = c
else:
    ch2[p] = c
```





### 연결 리스트

* 배열의 단점 보완
* 최대 2개의 자식 노드를 가지므로 일정한 구조의 단순 연결 리스트 노드를 사용해서 구현



## 이진 탐색 트리

* 탐색작업을 효율적으로 하기 위한 자료구조
* 모든 원소는 서로 다른 유일한 키를 갖는다
* key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
* 중위 순회하면 오름차순으로 정렬됨

### 탐색연산

* 루트에서 시작
* 탐색할 키 값x를 루트 노드의 키 값과 비교
  * 같으면 원하는 원소이므로 종료
  * x < 루트 : 왼쪽 서브트리에 대해서 탐색연산 수행
  * x > 루트 : 오른쪽 서브트리에 대해서 탐색연산 수행

### 삽입연산

* 먼저 탐색연산 수행
  * 삽입할 원소가 이미 있으면 삽입을 못하므로
  * 탐색에서 탐색실패가 결정되는 위치가 삽입 위치
* 탐색 실패한 위치에 원소 삽입 

### 성능

* 탐색(searching), 삽입(insertion), 삭제(deletion) 트리의 높이 만큼 시간
  * O(h)
* 평균
  * 이진 트리가 균형적일 때
  * O(log n)
* 최악의 경우
  * 한쪽으로 치우친 트리
  * O(n)
  * 순차탐색과 시간복잡도가 같음

## 힙

* 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조
* 힙에서는 루트 노드의 원소만 삭제 가능
* 힙의 키를 우선순위로 활용하여 우선순위 큐 구현 가능

### 최대 힙(max heap)

* 키 값이 가장 큰 노드를 찾기 위한 완전 이진트리
* 루트 노드 : 키 값이 가장 큰 노드
* 부모 키 값 > 자식 키 값

### 최소 힙(min heap)

* 키 값이 가장 작은 노드를 찾기 위한 완전 이진트리
* 루트 노드 : 키 값이 가장 작은 노드
* 부모 키 값 < 자식 키 값

### 삭제

* 힙에서는 루트 노드의 원소만을 삭제 가능, 최대 혹은 최소
* 루트 노드의 원소를 삭제하여 반환
* 힙의 종류에 따라 최대값 또는 최소값을 구할 수 있음
  * 우선순위 큐와 비교

1. 루트 노드 삭제
2. 마지막 노드 삭제 후 루트로 올리기
3. 자리 바꾸기



### 활용

* 우선순위 큐와 졍렬

* 우선순위 큐를 구현하는 가장 효율적인 방법이 힙을 사용

  * 노드 하나의 추가/삭제가 시간복잡도가 O(logn)이고 최대값/최소값을 O(1)에 구할 수 있다.
  * 완전 정렬보다 관리 비용이 적다.

* 배열을 통해 트리 형태를 구현 가능

  * 부모, 자식 노드를 O(1)로 찾을 수 있음
  * n 위치에 있는 노드의 자식은 2n과 2n+1
  * 완전 이진 트리의 특성에 의해 추가/삭제의 위치는 자료의 시작과 끝 인덱스로 쉽게 판단 가능 

* 힙 정렬을 이진 탐색과 유사

  1. 하나의 값을 힙에 삽입(반복)
  2. 힙에서 순차적(오름차순)으로 값을 하나씩 제거

  * 시간 복잡도
    * N개의 노드 삽입 연산 + N개의 노드 삭제 연산
    * 연산은 각각 O(log n)
    * O(nlog n)

